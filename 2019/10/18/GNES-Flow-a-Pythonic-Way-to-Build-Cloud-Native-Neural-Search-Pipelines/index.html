<!DOCTYPE html><html lang="en"><style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,header,main{display:block}a{background-color:transparent}h1{font-size:2em;margin:.67em 0}img{border:0}body,html{width:100%;height:100%}html{width:100%;height:100vh;display:flex;flex-direction:column;justify-content:center;align-items:center;background:var(--bgColor);--bgColor:#fff;--textColor:#2c3e50;--bg2ndColor:none;--bg3rdColor:#f8f8f8;--preCodeColor:#525252;--imgOpacity:1.0}@media (prefers-color-scheme:dark){html{background:var(--bgColor);--bgColor:#121212;--textColor:#fff;--bg2ndColor:#fff;--bg3rdColor:#332940;--preCodeColor:#f8f8f8;--imgOpacity:0.5}}body{margin:0;color:var(--textColor);font-size:18px;line-height:1.6;background-color:var(--bgColor);font-family:sourcesanspro,'Helvetica Neue',Arial,sans-serif}ul.nav{margin:0;padding:0;list-style-type:none}ul{margin:1rem 0}a{color:var(--textColor);text-decoration:none}.flag-icon{height:25px;width:25px;display:inline;border-radius:50%;vertical-align:sub}.icon_item{padding-left:5px!important;padding-right:5px!important}.reading-progress-bar{background:#42b983;display:block;height:2px;left:0;position:fixed;top:0;width:0;z-index:10001}header{min-height:60px}header .logo-link{float:left}header .nav{float:right;left:80px}header .logo-link img{height:60px}header .nav-list-item{display:inline-block;padding:19px 10px}header .nav-list-item a{line-height:1.4}@media screen and (max-width:900px){header .nav-list-item a{font-size:12px}}@media screen and (min-width:900px){header .nav-list-item a{font-size:18px}}.post{padding-top:1em}.post-block .post-title{margin:.65em 0;color:var(--textColor);font-size:1.5em}.post-block .post-info{color:#7f8c8d}.post-block .post-info .read-time{text-align:right}.post-content h2,.post-content h4{position:relative;margin:1em 0}.post-content h2 :before,.post-content h4 :before{content:"#";color:#42b983;position:absolute;left:-.7em;top:-4px;font-size:1.2em;font-weight:700}.post-content h4 :before{content:">"}.post-content h2{font-size:22px}.post-content h4{font-size:18px}.post-content a{color:#42b983;word-break:break-all}main.container{margin:2em 10px}@media screen and (min-width:900px){.wrap{width:900px;margin:0 auto}header{padding:20px 60px}}@media screen and (max-width:900px){.wrap{width:100%}header{min-height:50px;padding:2px 2px;position:fixed;z-index:10000;border-radius:15px;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}header a.logo-link,header ul.nav.nav-list{float:none;display:inline;text-align:center}header li.nav-list-item{padding:10px 5px}header .logo-link img{height:20px;vertical-align:sub}header .flag-icon{height:20px;width:20px}header{background-color:rgba(255,255,255,.9)}@supports ((-webkit-backdrop-filter:blur(2em)) or (backdrop-filter:blur(2em))){header{background-color:rgba(255,255,255,.3);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}}main.container{padding-top:2em}main.container{margin:0 20px}.post-content h2,.post-content h4{max-width:300px;left:15px}}@font-face{font-family:sourcesanspro;src:url(/font/sourcesanspro.woff2) format("woff2"),url(/font/sourcesanspro.woff) format("woff");font-weight:400;font-style:normal}</style><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> GNES Flow: a Pythonic Way to Build Cloud-Native Neural Search Pipelines · Han Xiao Tech Blog - Neural Search & AI Engineering</title><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@hxiao"><meta name="twitter:creator" content="@hxiao"><meta name="description" content="Since this March, GNES has evolved over 46 versions in the last six months. In the most recent release v0.0.46, we publish a new set of API called ... · Han Xiao"><meta property="og:title" content="GNES Flow: a Pythonic Way to Build Cloud-Native Neural Search Pipelines · Han Xiao Tech Blog - Neural Search &amp; AI Engineering"><meta property="og:description" content="Since this March, GNES has evolved over 46 versions in the last six months. In the most recent release v0.0.46, we publish a new set of API called ... · Han Xiao"><meta property="og:url" content="https://hanxiao.io/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/"><meta property="og:image" content="https://hanxiao.io/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines//gnes-flow-banner.png"><meta property="og:type" content="article"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/myavatar.png"><link rel="alternate" type="application/rss+xml" title="Han Xiao Tech Blog - Neural Search &amp; AI Engineering" href="https://hanxiao.io/atom.xml"><!-- - use css preload trick--><link rel="preload" href="/css/apollo.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/apollo.css"></noscript><script>/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/
(function( w ){
    "use strict";
    // rel=preload support test
    if( !w.loadCSS ){
        w.loadCSS = function(){};
    }
    // define on the loadCSS obj
    var rp = loadCSS.relpreload = {};
    // rel=preload feature support test
    // runs once and returns a function for compat purposes
    rp.support = (function(){
        var ret;
        try {
            ret = w.document.createElement( "link" ).relList.supports( "preload" );
        } catch (e) {
            ret = false;
        }
        return function(){
            return ret;
        };
    })();

    // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
    // then change that media back to its intended value on load
    rp.bindMediaToggle = function( link ){
        // remember existing media attr for ultimate state, or default to 'all'
        var finalMedia = link.media || "all";

        function enableStylesheet(){
            link.media = finalMedia;
        }

        // bind load handlers to enable media
        if( link.addEventListener ){
            link.addEventListener( "load", enableStylesheet );
        } else if( link.attachEvent ){
            link.attachEvent( "onload", enableStylesheet );
        }

        // Set rel and non-applicable media type to start an async request
        // note: timeout allows this to happen async to let rendering continue in IE
        setTimeout(function(){
            link.rel = "stylesheet";
            link.media = "only x";
        });
        // also enable media after 3 seconds,
        // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
        setTimeout( enableStylesheet, 3000 );
    };

    // loop through link elements in DOM
    rp.poly = function(){
        // double check this to prevent external calls from running
        if( rp.support() ){
            return;
        }
        var links = w.document.getElementsByTagName( "link" );
        for( var i = 0; i < links.length; i++ ){
            var link = links[ i ];
            // qualify links to those with rel=preload and as=style attrs
            if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
                // prevent rerunning on link
                link.setAttribute( "data-loadcss", true );
                // bind listeners to toggle media back
                rp.bindMediaToggle( link );
            }
        }
    };

    // if unsupported, run the polyfill
    if( !rp.support() ){
        // run once at least
        rp.poly();

        // rerun poly on an interval until onload
        var run = w.setInterval( rp.poly, 500 );
        if( w.addEventListener ){
            w.addEventListener( "load", function(){
                rp.poly();
                w.clearInterval( run );
            } );
        } else if( w.attachEvent ){
            w.attachEvent( "onload", function(){
                rp.poly();
                w.clearInterval( run );
            } );
        }
    }


    // commonjs
    if( typeof exports !== "undefined" ){
        exports.loadCSS = loadCSS;
    }
    else {
        w.loadCSS = loadCSS;
    }
}( typeof global !== "undefined" ? global : this ) );</script><script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/7da58fc9885cb85d4a9f0ad9a/987f901145f1749fd3e800e86.js");</script><link rel="search" type="application/opensearchdescription+xml" href="https://hanxiao.io/atom.xml" title="Han Xiao Tech Blog - Neural Search &amp; AI Engineering"></head><body><div class="reading-progress-bar"></div><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.linkedin.com/in/hxiao87" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="https://x.com/hxiao" target="_blank" class="nav-list-link">X</a></li><li class="nav-list-item"><a href="https://github.com/hanxiao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://scholar.google.com/citations?user=jp7swwIAAAAJ" target="_blank" class="nav-list-link">SCHOLAR</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">GNES Flow: a Pythonic Way to Build Cloud-Native Neural Search Pipelines</h1><div class="post-info">Oct 18, 2019 by &nbsp;&nbsp;&nbsp;<img src="/myavatar.png" alt="logo" width="18px" height="18px" style="vertical-align: sub;">&nbsp;<a href="/about" target="_blank" class="nav-list-link">Han Xiao - <i>ex</i> Engineering Lead @ Tencent AI Lab</a></div><div class="post-info"><div class="read-time">◷&nbsp;&nbsp;&nbsp; 16  min read</div></div><div class="post-content"><h2><span id="background">Background</span></h2><div class="remind"><br>  For those who don’t know about <a href="https://github.com/gnes-ai/gnes" target="_blank" rel="noopener">GNES</a>. GNES <code>[jee-nes]</code> is Generic Neural Elastic Search, a cloud-native semantic search system based on deep neural network. GNES enables large-scale index and semantic search for text-to-text, image-to-image, video-to-video and any-to-any content form. More information can be found in <a href="https://github.com/gnes-ai/gnes" target="_blank" rel="noopener">our Github repository</a>.<br></div>


<p>Since this March, <a href="https://github.com/gnes-ai/gnes" target="_blank" rel="noopener">GNES</a> has evolved over <a href="https://github.com/gnes-ai/gnes/blob/master/CHANGELOG.md" target="_blank" rel="noopener">46 versions</a> in the last six months. In the most recent release <code>v0.0.46</code>, we publish a new set of API called GNES Flow. It offers a <em>pythonic</em> way for users to construct pipelines in GNES with clean, readable idioms. <a id="more"></a> As an example, an indexing pipeline can be written as:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gnes.flow <span class="keyword">import</span> Flow</span><br><span class="line">flow = (Flow(check_version=<span class="literal">False</span>)</span><br><span class="line">        .add_preprocessor(name=<span class="string">'prep'</span>, yaml_path=<span class="string">'yaml/prep.yml'</span>)</span><br><span class="line">        .add_encoder(yaml_path=<span class="string">'yaml/incep-v4.yml'</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'vec_idx'</span>, yaml_path=<span class="string">'yaml/vec.yml'</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'doc_idx'</span>, yaml_path=<span class="string">'yaml/doc.yml'</span>, recv_from=<span class="string">'prep'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'sync'</span>, yaml_path=<span class="string">'BaseReduceRouter'</span>, num_part=<span class="number">2</span>, recv_from=[<span class="string">'vec_idx'</span>, <span class="string">'doc_idx'</span>]))</span><br></pre></td></tr></table></figure>
<p>And then used via:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> flow.build(backend=<span class="string">'process'</span>) <span class="keyword">as</span> fl:</span><br><span class="line">    fl.index(bytes_gen=read_flowers(), batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></p>
<p>One can easily visualize the flow and export it to a SVG image via <code>flow.build(backend=None).to_url()</code></p>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/b18fd775.png">
<p>In this post, I will explain the motivation behind GNES Flow and highlight some example usages on how this new API can significantly improve the usability of GNES.</p>
<h4><span id="table-of-content">Table of Content</span></h4><!-- toc -->
<ul>
<li><a href="#the-motivation-behind-gnes-flow">The Motivation Behind GNES Flow</a><ul>
<li><a href="#pain-points">Pain points</a></li>
<li><a href="#highlights-of-gnes-flow">Highlights of GNES Flow</a></li>
</ul>
</li>
<li><a href="#example-usage">Example Usage</a><ul>
<li><a href="#define-an-empty-flow">Define an empty flow</a></li>
<li><a href="#use-a-flow">Use a flow</a></li>
<li><a href="#add-a-microservice-to-an-flow">Add a microservice to an flow</a></li>
<li><a href="#visualize-a-flow">Visualize a flow</a></li>
<li><a href="#define-a-more-complicated-pipeline">Define a more complicated pipeline</a></li>
<li><a href="#modify-the-attribute-of-a-component-in-a-flow">Modify the attribute of a component in a flow</a></li>
<li><a href="#elastic-scale-out-a-flow">Elastic: scale out a flow</a></li>
<li><a href="#define-an-index-flow">Define an index flow</a></li>
<li><a href="#define-a-query-flow">Define a query flow</a></li>
<li><a href="#convert-a-index-flow-to-query-flow">Convert a index flow to query flow</a></li>
<li><a href="#export-the-flow-to-docker-swarm-config">Export the flow to Docker Swarm config</a></li>
</ul>
</li>
<li><a href="#whats-next">What’s Next?</a></li>
</ul>
<!-- tocstop -->
<h2><span id="the-motivation-behind-gnes-flow">The Motivation Behind GNES Flow</span></h2><h4><span id="pain-points">Pain points</span></h4><p>Before GNES Flow, the only recommended way to run GNES is via a third-party orchestration, e.g. Docker Swarm and Kubernetes. Basically, one has to write a YAML config that composes all microservices as the following (a Docker Swarm config):<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">Frontend0:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">frontend</span> <span class="string">--port_in</span> <span class="number">56086</span> <span class="string">--port_out</span> <span class="number">52674</span> <span class="string">--port_ctrl</span> <span class="number">49225</span> <span class="string">--check_version</span></span><br><span class="line">      <span class="literal">False</span> <span class="string">--ctrl_with_ipc</span> <span class="literal">True</span></span><br><span class="line">  <span class="attr">prep:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">preprocess</span> <span class="string">--port_in</span> <span class="number">52674</span> <span class="string">--port_out</span> <span class="number">65461</span> <span class="string">--host_in</span> <span class="string">Frontend0</span> <span class="string">--socket_in</span></span><br><span class="line">      <span class="string">PULL_CONNECT</span> <span class="string">--socket_out</span> <span class="string">PUB_BIND</span> <span class="string">--port_ctrl</span> <span class="number">49281</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--ctrl_with_ipc</span></span><br><span class="line">      <span class="literal">True</span> <span class="string">--yaml_path</span> <span class="string">yaml/prep.yml</span></span><br><span class="line"><span class="comment"># MORE OF THESE CODES ARE OMITTED...</span></span><br><span class="line">  <span class="attr">sync:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">route</span> <span class="string">--port_in</span> <span class="number">57791</span> <span class="string">--port_out</span> <span class="number">56086</span> <span class="string">--host_out</span> <span class="string">Frontend0</span> <span class="string">--socket_out</span></span><br><span class="line">      <span class="string">PUSH_CONNECT</span> <span class="string">--port_ctrl</span> <span class="number">51285</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--ctrl_with_ipc</span> <span class="literal">True</span> <span class="string">--yaml_path</span></span><br><span class="line">      <span class="string">BaseReduceRouter</span> <span class="string">--num_part</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>The drawback of writing such handcrafted config is pretty obvious: <strong>it is error-prone</strong>. One can easily make mistakes on <code>port_in</code>, <code>port_out</code>, <code>socket_in</code> and <code>socket_out</code> arguments, which define the underlying network topology. Moreover, the topology is not straightforward to see given this config. For users who are not familiar with Docker/Kubernetes, this config can be cumbersome. <a href="https://board.gnes.ai" target="_blank" rel="noopener">GNES Board</a> (depreciated since <code>v0.0.46</code>) was one attempt to alleviate this problem, but it is not enough. In principle, these arguments about ports can be automatically determined once the network topology is fixed. Namely, <strong>the topology defines the configs, not the other way round</strong>. Therefore, a more reasonable user journey would be: let the user specify the network topology first, and then generate the corresponding sockets and ports configs. The first step should be as intuitive as possible, whereas the latter should be hided from the user.</p>
<p>The second drawback is that <strong>it is hard to debug</strong> GNES on a local machine. As GNES is designed to be a cloud-native framework from the day one, we did not put running GNES in a local environment as the priority. Nonetheless, there is still a way to do so. In our <a href="https://github.com/gnes-ai/gnes/tree/master/tests" target="_blank" rel="noopener">unit tests</a>, we keep working with the following pattern to build a toy network without using Docker Swarm/Kubernetes:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gnes.cli.parser <span class="keyword">import</span> set_router_parser, _set_client_parser</span><br><span class="line"></span><br><span class="line">args = set_router_parser().parse_args([</span><br><span class="line">    <span class="string">'--yaml_path'</span>, self.concat_router_yaml,</span><br><span class="line">    <span class="string">'--socket_out'</span>, str(SocketType.PUSH_BIND)])</span><br><span class="line">    </span><br><span class="line">c_args = _set_client_parser().parse_args([</span><br><span class="line">    <span class="string">'--port_in'</span>, str(args.port_out),</span><br><span class="line">    <span class="string">'--port_out'</span>, str(args.port_in),</span><br><span class="line">    <span class="string">'--socket_in'</span>, str(SocketType.PULL_CONNECT)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> RouterService(args), ZmqClient(c_args) <span class="keyword">as</span> c1:</span><br><span class="line">    msg = gnes_pb2.Message()</span><br><span class="line">    c1.send_message(msg)</span><br><span class="line">    r = c1.recv_message()</span><br></pre></td></tr></table></figure>
<p>One may also consider this pattern as an orchestration layer built on top of Python multi-thread (as <code>BaseService</code> class is inherited from <code>Thread</code>). Comparing to the cloud-native alternatives, this is much easier to debug, print traceback and set breakpoints. However, users who want to reuse this pattern in their own code would still have to manually specify the ports as the parsed arguments in order to define the topology. Besides, it also involves quite some low-level network ops such as binding ZeroMQ sockets and establishing gRPC channels &amp; stubs. We want to generalize this pattern and make it more handy, as easy and natural as possible for a GNES users to pick up.</p>
<h4><span id="highlights-of-gnes-flow">Highlights of GNES Flow</span></h4><p>With all these considerations in mind, our goal is to build a new API for GNES and provide a <em>readable</em> and <em>brief idiom</em>, which separates the construction of a complex pipeline from its representation. In some sense, GNES Flow to GNES is like Keras to Tensorflow. Specifically, one can use it to </p>
<ul>
<li>chain multiple <code>add()</code> functions to build a pipeline;</li>
<li>use self-defined names instead of ports to a service;</li>
<li>modify a pipeline’s component via <code>set()</code>;</li>
<li>run a pipeline on multiple orchestration layers, e.g. multi-thread, multi-process, Docker Swarm, Kubernetes;</li>
<li>serialize/deserialize a pipeline to/from a binary file, a SVG image, Docker Swarm/Kubernetes config files.</li>
</ul>
<p>If you are interested in knowing more about the design patterns behind the GNES Flow, then <a href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener">method chaining</a>, <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="noopener">lazy evaluation</a> are the keywords you may want to search for. </p>
<h2><span id="example-usage">Example Usage</span></h2><img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/446f49f9.png">
<p><a href="https://github.com/gnes-ai/demo-gnes-flow" target="_blank" rel="noopener">In this repository</a> I showed an example on how to build a toy image search system for indexing and retrieving flowers based on their similarities. <a href="https://github.com/gnes-ai/demo-gnes-flow" target="_blank" rel="noopener">The Jupyter Notebook can be found here</a>. <a href="http://doc.gnes.ai/en/latest/api/gnes.flow.html" target="_blank" rel="noopener">The complete documentation of GNES Flow can be found at here</a>. In the sequel, I will highlight some common usages.</p>
<h4><span id="define-an-empty-flow">Define an empty flow</span></h4><p>Defining a flow is easy. One can simply initialize a <code>Flow</code> object.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gnes.flow <span class="keyword">import</span> Flow</span><br><span class="line"></span><br><span class="line">flow = Flow(check_version=<span class="literal">False</span>, ctrl_with_ipc=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>Here <code>check_version=False</code> and <code>ctrl_with_ipc=True</code> serve as the “global” arguments, they will override all microservices added afterwards.  </p>
<p>Note, due to the <em>lazy evaluation</em> feature of GNES Flow, <em>nothing</em> is really “executed” until we call <code>flow.build()</code> and use it as a context manager, which we shall see later. In some sense, it is like <code>tf.Session</code> in Tensorflow.</p>
<h4><span id="use-a-flow">Use a flow</span></h4><p>To use a flow for indexing, searching and training, you need to first <code>build</code> it with some backend and then use it as a context manager as following:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> flow.build(backend=<span class="string">'process'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.index(txt_file=self.test_file, batch_size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> flow.build(backend=<span class="string">'thread'</span>) <span class="keyword">as</span> f,  open(self.test_file, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    f.index(bytes_gen=[v.encode() <span class="keyword">for</span> v <span class="keyword">in</span> fp])</span><br></pre></td></tr></table></figure>
<p>This will start a <code>CLIClient</code> and connect it to the flow. As defined in <code>CLIClient</code>, the available methods here are <code>index</code>, <code>query</code> and <code>train</code>. To feed data to the flow, one can use built-in readers to read files into an iterator of bytes, or write a generator by your own. Please refer to <a href="http://doc.gnes.ai/en/latest/api/gnes.flow.html#gnes.flow.Flow.index" target="_blank" rel="noopener">the documentation for more details</a>. </p>
<p>The available backends are <code>None</code> (dry-run for a sanity check and visualization), <code>thread</code> and <code>process</code>. In the future, <code>swarm</code> and <code>k8s</code> will be implemented.</p>
<h4><span id="add-a-microservice-to-an-flow">Add a microservice to an flow</span></h4><p>Adding microservice is simply chaining <code>add()</code> on an existing flow object. There are two ways to call <code>add</code>, e.g.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flow = (Flow(check_version=<span class="literal">False</span>, ctrl_with_ipc=<span class="literal">True</span>)</span><br><span class="line">        .add_router(yaml_path=<span class="string">'BaseRouter'</span>)</span><br><span class="line">        .add(<span class="string">'Router'</span>, yaml_path=<span class="string">'BaseRouter'</span>))  <span class="comment"># another way to use `add`</span></span><br></pre></td></tr></table></figure>
<p>The last added microservice will automatically receive the output from the previous added microservice. By default, the first microservice in the flow will receive the output from the <a href="http://doc.gnes.ai/en/latest/chapter/microservice.html#frontend" target="_blank" rel="noopener"><code>Frontend</code></a>, and the last microservice in the flow will send its output back to the <code>Frontend</code>.</p>
<p>Currently GNES Flow supports the following <code>add</code> methods:</p>
<ul>
<li><code>add_router(**kwargs)</code> or <code>add(&#39;Router&#39;, **kwargs)</code></li>
<li><code>add_encoder(**kwargs)</code> or <code>add(&#39;Encoder&#39;, **kwargs)</code></li>
<li><code>add_preprocessor(**kwargs)</code> or <code>add(&#39;Preprocessor&#39;, **kwargs)</code></li>
<li><code>add_indexer(**kwargs)</code> or <code>add(&#39;Preprocessor&#39;, **kwargs)</code></li>
</ul>
<p>The accepted <code>**kwargs</code> of each function can be found in <a href="http://doc.gnes.ai/en/latest/chapter/microservice.html" target="_blank" rel="noopener">the CLI documentation of each microservice</a>.</p>
<h4><span id="visualize-a-flow">Visualize a flow</span></h4><p>You can export a flow object by exporting it to a SVG URL and opening it in browser.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow.build(backend=<span class="literal">None</span>).to_url()</span><br></pre></td></tr></table></figure>
<p>Note, <code>backend=None</code> specifies that we just do a “dry-run” with no particular orchestration. This is useful when you simply want to perform a sanity check on the connectivity of the pipeline without really spawning all microservices.</p>
<p>If you are using Jupyter Notebook, then you can simply print the visualization inline via:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line">IFrame(src=flow.build(backend=<span class="literal">None</span>).to_url(), width=<span class="number">900</span>, height=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/5dabd974.png">
<h4><span id="define-a-more-complicated-pipeline">Define a more complicated pipeline</span></h4><p>To generalize the topology of a pipeline, e.g., let a microservice receiving inputs from not the last but some upper stream components, or making some map-reduce patterns in the pipeline, you will need to name service when you add it. For example,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow = (Flow()</span><br><span class="line">        .add_router(name=<span class="string">'r1'</span>, yaml_path=<span class="string">'BaseRouter'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r2'</span>, yaml_path=<span class="string">'BaseRouter'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r3'</span>, yaml_path=<span class="string">'BaseRouter'</span>, recv_from=<span class="string">'r1'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r4'</span>, yaml_path=<span class="string">'BaseRouter'</span>, recv_from=[<span class="string">'r2'</span>,<span class="string">'r3'</span>]))</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/f3a92635.png">
<h4><span id="modify-the-attribute-of-a-component-in-a-flow">Modify the attribute of a component in a flow</span></h4><p>Once a flow is defined, you can use <code>set</code> to change the attributes of a specific component:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flow = (flow.set(<span class="string">'r3'</span>, recv_from=<span class="string">'r2'</span>, clear_old_attr=<span class="literal">True</span>)</span><br><span class="line">            .set(<span class="string">'r4'</span>, recv_from=<span class="string">'r3'</span>, clear_old_attr=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/c353cad8.png">
<p>You can also use <code>remove</code> to delete a component from the flow, or use <code>set_last_service</code> to set a service as the last service in the flow. These functions are particular useful when you want to partially reuse a flow.</p>
<h4><span id="elastic-scale-out-a-flow">Elastic: scale out a flow</span></h4><p>Elasticity or scalability can be achieved by simply adding <code>replicas</code> (alias to <code>num_parallel</code>) to each microservice, e.g.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flow = (Flow()</span><br><span class="line">        .add_router(name=<span class="string">'r1'</span>, yaml_path=<span class="string">'BaseRouter'</span>, replicas=<span class="number">4</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r2'</span>, yaml_path=<span class="string">'BaseRouter'</span>, replicas=<span class="number">3</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r3'</span>, yaml_path=<span class="string">'BaseRouter'</span>, recv_from=<span class="string">'r1'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'r4'</span>, yaml_path=<span class="string">'BaseRouter'</span>, recv_from=[<span class="string">'r2'</span>,<span class="string">'r3'</span>]))</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/74d47d5b.png">
<h4><span id="define-an-index-flow">Define an index flow</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gnes.flow <span class="keyword">import</span> Flow</span><br><span class="line"></span><br><span class="line">flow = (Flow(check_version=<span class="literal">False</span>, ctrl_with_ipc=<span class="literal">True</span>)</span><br><span class="line">        .add_preprocessor(name=<span class="string">'prep'</span>, yaml_path=<span class="string">'yaml/prep.yml'</span>, replicas=<span class="number">2</span>)</span><br><span class="line">        .add_encoder(yaml_path=<span class="string">'yaml/incep.yml'</span>, replicas=<span class="number">4</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'vec_idx'</span>, yaml_path=<span class="string">'yaml/vec.yml'</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'doc_idx'</span>, yaml_path=<span class="string">'yaml/doc.yml'</span>, recv_from=<span class="string">'prep'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'sync'</span>, yaml_path=<span class="string">'BaseReduceRouter'</span>, num_part=<span class="number">2</span>, recv_from=[<span class="string">'vec_idx'</span>, <span class="string">'doc_idx'</span>]))</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/085a7888.png">
<h4><span id="define-a-query-flow">Define a query flow</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gnes.flow <span class="keyword">import</span> Flow</span><br><span class="line"></span><br><span class="line">flow = (Flow(check_version=<span class="literal">False</span>)</span><br><span class="line">        .add_preprocessor(name=<span class="string">'prep'</span>, yaml_path=<span class="string">'yaml/prep.yml'</span>, replicas=<span class="number">2</span>)</span><br><span class="line">        .add_encoder(yaml_path=<span class="string">'yaml/incep.yml'</span>, replicas=<span class="number">4</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'vec_idx'</span>, yaml_path=<span class="string">'yaml/vec.yml'</span>)</span><br><span class="line">        .add_router(name=<span class="string">'scorer'</span>, yaml_path=<span class="string">'yaml/score.yml'</span>)</span><br><span class="line">        .add_indexer(name=<span class="string">'doc_idx'</span>, yaml_path=<span class="string">'yaml/doc.yml'</span>))</span><br></pre></td></tr></table></figure>
<img src="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/771e03b9.png">
<h4><span id="convert-a-index-flow-to-query-flow">Convert a index flow to query flow</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flow = (flow</span><br><span class="line">          .remove(<span class="string">'sync_barrier'</span>)</span><br><span class="line">          .remove(<span class="string">'doc_idx'</span>)</span><br><span class="line">          .set_last_service(<span class="string">'vec_idx'</span>)</span><br><span class="line">          .add_router(<span class="string">'scorer'</span>, yaml_path=<span class="string">'yaml/flow-score.yml'</span>)</span><br><span class="line">          .add_indexer(<span class="string">'doc_idx'</span>, yaml_path=<span class="string">'DictIndexer'</span>))</span><br></pre></td></tr></table></figure>
<h4><span id="export-the-flow-to-docker-swarm-config">Export the flow to Docker Swarm config</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow.build(backend=<span class="literal">None</span>).to_swarm_yaml()</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">Frontend0:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">frontend</span> <span class="string">--port_in</span> <span class="number">53673</span> <span class="string">--port_out</span> <span class="number">55125</span> <span class="string">--port_ctrl</span> <span class="number">64663</span> <span class="string">--check_version</span></span><br><span class="line">      <span class="literal">False</span></span><br><span class="line">  <span class="attr">prep:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">preprocess</span> <span class="string">--port_in</span> <span class="number">55125</span> <span class="string">--port_out</span> <span class="number">56148</span> <span class="string">--host_in</span> <span class="string">Frontend0</span> <span class="string">--socket_in</span></span><br><span class="line">      <span class="string">PULL_CONNECT</span> <span class="string">--port_ctrl</span> <span class="number">60579</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--yaml_path</span> <span class="string">yaml/prep.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">Encoder0:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">encode</span> <span class="string">--port_in</span> <span class="number">56148</span> <span class="string">--port_out</span> <span class="number">60474</span> <span class="string">--host_in</span> <span class="string">prep</span> <span class="string">--socket_in</span> <span class="string">PULL_CONNECT</span></span><br><span class="line">      <span class="string">--port_ctrl</span> <span class="number">61582</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--yaml_path</span> <span class="string">yaml/incep.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">vec_idx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">index</span> <span class="string">--port_in</span> <span class="number">60474</span> <span class="string">--port_out</span> <span class="number">54680</span> <span class="string">--host_in</span> <span class="string">Encoder0</span> <span class="string">--socket_in</span></span><br><span class="line">      <span class="string">PULL_CONNECT</span> <span class="string">--port_ctrl</span> <span class="number">52274</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--yaml_path</span> <span class="string">yaml/vec.yml</span></span><br><span class="line">  <span class="attr">scorer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">route</span> <span class="string">--port_in</span> <span class="number">54680</span> <span class="string">--port_out</span> <span class="number">59412</span> <span class="string">--host_in</span> <span class="string">vec_idx</span> <span class="string">--socket_in</span></span><br><span class="line">      <span class="string">PULL_CONNECT</span> <span class="string">--port_ctrl</span> <span class="number">50906</span> <span class="string">--check_version</span> <span class="literal">False</span> <span class="string">--yaml_path</span> <span class="string">yaml/score.yml</span></span><br><span class="line">  <span class="attr">doc_idx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gnes/gnes:latest-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">index</span> <span class="string">--port_in</span> <span class="number">59412</span> <span class="string">--port_out</span> <span class="number">53673</span> <span class="string">--host_in</span> <span class="string">scorer</span> <span class="string">--host_out</span> <span class="string">Frontend0</span></span><br><span class="line">      <span class="string">--socket_in</span> <span class="string">PULL_CONNECT</span> <span class="string">--socket_out</span> <span class="string">PUSH_CONNECT</span> <span class="string">--port_ctrl</span> <span class="number">55675</span> <span class="string">--check_version</span></span><br><span class="line">      <span class="literal">False</span> <span class="string">--yaml_path</span> <span class="string">yaml/doc.yml</span></span><br></pre></td></tr></table></figure>
<p>Note how the ports and sockets are correctly set automatically.</p>
<h2><span id="whats-next">What’s Next?</span></h2><p>GNES Flow provides a clean and readable way to use GNES especially in a local environment. It significantly reduces the learning curve of GNES. The current implementation of GNES Flow has still limitations. For example, it requires all dependencies (e.g. tensorflow, pytorch) to be installed locally; it does not support setting the GNES Docker image per microservice, which can not leverage the full power of <a href="https://github.com/gnes-ai/hub" target="_blank" rel="noopener">GNES Hub</a>. If you are interested in making GNES Flow even better/cooler, feel free to <a href="https://github.com/gnes-ai/gnes/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">make a contribution here</a>.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/07/A-Better-Practice-for-Managing-extras-require-Dependencies-in-Python/" class="prev">&nbsp;❮&nbsp;&nbsp;A Better Practice fo...</a><a href="/2019/07/29/Generic-Neural-Elastic-Search-From-bert-as-service-and-Go-Way-Beyond/" class="next">Generic Neural Elast...&nbsp;&nbsp;❯&nbsp;</a></div><div class="footer-section"><h2><img src="/flower.png" alt="Checkout this">Check out these posts too!</h2><div class="archive-readmore"><div style="display: flex; gap: 10px; align-items: flex-start;" class="post-item"><a href="/2019/11/22/Video-Semantic-Search-in-Large-Scale-using-GNES-and-TF-2-0/"><img src="https://hanxiao.io/2019/11/22/Video-Semantic-Search-in-Large-Scale-using-GNES-and-TF-2-0//9ba076d0.png" alt="Video Semantic Search in Large Scale using GNES and Tensorflow 2.0" style="width: 120px; height: 90px; object-fit: cover;"></a><div style="flex: 1;" class="book-title"><h5 style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin: 0;" class="post-title"><a href="/2019/11/22/Video-Semantic-Search-in-Large-Scale-using-GNES-and-TF-2-0/" class="post-title-link">Video Semantic Search in Large Scale using GNES and Tensorflow 2.0</a></h5></div></div><div style="display: flex; gap: 10px; align-items: flex-start;" class="post-item"><a href="/2019/11/07/A-Better-Practice-for-Managing-extras-require-Dependencies-in-Python/"><img src="https://hanxiao.io/2019/11/07/A-Better-Practice-for-Managing-extras-require-Dependencies-in-Python//banner.png" alt="A Better Practice for Managing Many &lt;code&gt;extras_require&lt;/code&gt; Dependencies in Python" style="width: 120px; height: 90px; object-fit: cover;"></a><div style="flex: 1;" class="book-title"><h5 style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin: 0;" class="post-title"><a href="/2019/11/07/A-Better-Practice-for-Managing-extras-require-Dependencies-in-Python/" class="post-title-link">A Better Practice for Managing Many <code>extras_require</code> Dependencies in Python</a></h5></div></div><div style="display: flex; gap: 10px; align-items: flex-start;" class="post-item"><a href="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/"><img src="https://hanxiao.io/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines//gnes-flow-banner.png" alt="GNES Flow: a Pythonic Way to Build Cloud-Native Neural Search Pipelines" style="width: 120px; height: 90px; object-fit: cover;"></a><div style="flex: 1;" class="book-title"><h5 style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin: 0;" class="post-title"><a href="/2019/10/18/GNES-Flow-a-Pythonic-Way-to-Build-Cloud-Native-Neural-Search-Pipelines/" class="post-title-link">GNES Flow: a Pythonic Way to Build Cloud-Native Neural Search Pipelines</a></h5></div></div><div style="display: flex; gap: 10px; align-items: flex-start;" class="post-item"><a href="/2019/07/29/Generic-Neural-Elastic-Search-From-bert-as-service-and-Go-Way-Beyond/"><img src="https://hanxiao.io/2019/07/29/Generic-Neural-Elastic-Search-From-bert-as-service-and-Go-Way-Beyond//gnes-team-1600.JPG" alt="Generic Neural Elastic Search: From &lt;code&gt;bert-as-service&lt;/code&gt; and Go Way Beyond" style="width: 120px; height: 90px; object-fit: cover;"></a><div style="flex: 1;" class="book-title"><h5 style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; margin: 0;" class="post-title"><a href="/2019/07/29/Generic-Neural-Elastic-Search-From-bert-as-service-and-Go-Way-Beyond/" class="post-title-link">Generic Neural Elastic Search: From <code>bert-as-service</code> and Go Way Beyond</a></h5></div></div></div></div><div class="copyright"><p>© 2017 - 2025 <a href="https://hanxiao.io">Han Xiao</a>. <img src="/by-nc-sa.svg" alt="Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License." class="image"></p></div></footer></div><link rel="stylesheet" href="/css/post/katex.min.css"><!--link(rel="stylesheet", href=url_for("css/post/gitment.css"))--><script src="/js/katex.min.js"></script><script src="/js/auto-render.min.js"></script><script>renderMathInElement(
    document.body,
    {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    }
);</script><!--script(src=url_for("js/gitment.browser.js"))--><!--script(src=url_for("js/gitment.loader.js"))--><script src="/js/jquery-3.4.1.min.js"></script><script src="/js/reading_progress.min.js"></script><script src="/js/highlighter.min.js"></script><script src="/js/init-highlighter.js"></script><script async src="https://www.google-analytics.com/analytics.js"></script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create',"UA-52114253-1",'auto');ga('send','pageview');</script></body></html>